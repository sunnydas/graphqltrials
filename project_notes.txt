https://www.howtographql.com/graphql-java/0-introduction/

 it is similar to a database server that parses, validates and executes SQL queries. 
 
 GraphQL conveniently does away with this hurdle by making the decision of what data gets fetched the exclusive domain of the client, opening in turn a path to a much smoother API evolution. This is further complemented by GraphQL’s self-describing nature (via introspection queries), making contract-first (or rather schema-first, in GraphQL lingo) approach both natural and easy.
 
 The schema in GraphQL is the central contract between the client and the server, describing all the types of data and all the operations (queries and mutations) upon those types the server offers. Beyond the usual promise of client-server independence and easy mocking, developing in the schema-first style helps enforce the good practice of structuring the logic into smaller and simpler functions (the single responsibility principle) that can conveniently be used as resolvers.
 
 Project Steps:
 
 mvn archetype:generate -DarchetypeArtifactId=maven-archetype-webapp -DgroupId=com.sunny.graphql.helloworld -DartifactId=sunny-graphql-java -Dversion=1.0-SNAPSHOT
 
 You can run the app just by executing mvn jetty:run in the directory where pom.xml is located, and Jetty will start on port 8080.
 
 graphql-java-tools defines two types of classes: data classes, which model the domain and are usually simple POJOs, and resolvers, that model the queries and mutations and contain the resolver functions. Often, both are needed to model a single GraphQL type.
 
 http://localhost:8080/helloworld/graphql?query=%7BallLinks%7Burl%7D%7D
 
 http://localhost:8080/helloworld/graphql?query={allLinks{url}} 

 
 D:\project\PhoenixRising\Training\GraphQL>"C:\Program Files\MongoDB\Server\3.4\bin\mongod" --dbpath "D:\project\PhoenixRising\Training\GraphQL\data"
 
 You may have noticed that the execution strategy seen so far is somewhat naive. Imagine the link descriptions are stored in a different database. That would mean for a query like this
 
 the resolver for the description field (invoked once for each link in the result) would query that other database as many times are there were links. This a classic example of the N+1 problem. The solution for this is to batch multiple requests and resolve them in one go. In case of a SQL database, the desired resolver would look like:
 SELECT * FROM Descriptions WHERE link_id IN (1,2,3) // fetch descriptions for 3 links at once
 
 What is the N+1 Query Problem ?
This problem occurs when the code needs to load the children of a parent-child relationship (the “many” in the “one-to-many”). Most ORMs have lazy-loading enabled by default, so queries are issued for the parent record, and then one query for EACH child record. As you can expect, doing N+1 queries instead of a single query will flood your database with queries, which is something we can and should avoid.

In JavaScript and a few other languages, a popular way to implement this strategy is the DataLoader utility. The Java implementation of DataLoader is unfortunately still in the making.
As an alternative, graphql-java offers BatchedExecutionStrategy, which looks for resolvers (DataFetchers in graphql-java lingo) annotated by @Batched. Such resolvers are expected to take a list of source objects and return a list of results. For the example above, that would mean taking a list of links (List<Link>) and returning a list of descriptions (List<String>). Again unfortunately, graphql-java-tools does not yet support batched data fetchers, but it hopefully soon will.

push an existing repository from the command line

git remote add origin https://github.com/sunnydas/graphqltrials.git
git push -u origin master